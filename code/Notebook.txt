SURFACES:
    -images
    -windows
    how to create
        plain surface: pygame.Surface((width,height)) or
        imported surface: pygame.image.load(path)
            to make your file path dynamic, use the join method
                You do this by importing join from os.path and then calling the method with the
                parameters being your folder and file.
            When importing an image, convert it to a form pygame can easily work with
                no transparent pixels : .convert()
                transparent pixels: .convert_alpha()
        text surface: font.render(text, AntiAlias, Colour)

RECTANGLES
    - wraps around a surface and positions it, also lets you do collisions
    points on a rect can be defined either as tuples(x,y), for
        - top left,top mid, top right, center, mid left, mid right, and bottoms
    or as X or Y positions.
    rectangles also have a width, height, and size.
    each point can be measured and changed, and they also stay relative to each other, move one, move all.

    there are 2 types of rectangles ,
        -Rects: uses integers to store data
        - floating point rects or FRects : these store data as floating point values, are much more precise
            and are used more often


    Creating rects:
        - From scratch
            pygame.Rect(pos,size)
            pygame.FRect(pos,size)
        - From a surface(it would have the same size as the surface)
            surface.get_rect(point = pos)
            surface.get_frect(point = pos)

VECTORS
    a list with values x and y
    vector(x, y)
        you can access them like you do any list : vector[0] =1
        or just vector.x = 1
    to create one:
        pygame.math.vector2(x,y) #for a 2d vector
    they work like they do in maths so the vector can be scalarr multiplied and added to other vectors
    you can also add a vector to the tuple position of a rectangle, changing both x and y at the same time

FRAMERATE INDEPENDENCE
Delta time:
		Delta time is the time difference between the current and previous frames, so the time it takes to create a new frame.
		We multiply this value with any movement in the game making the game run consistently no matter the frame rate.

		movement x frame rate x delta  time

		examples
		FPS | pixel/frame or intended movement | frame rate | delta    |  actual movement pixel/second
		10		10									30			1/30		10
		30		10									60			1/60		10
		60		10									600			1/600		10

		caveats with delta time
			- when you use delta time, you have to multiply ANY movement so animations, rotations, ANYTHING!
			- You have to use larger numbers to move things(not 10 definitely not 10 lol)

		ways to use delta time
		 Dt = clock.tick(frame rate)
			used to limit frame rate but also retains dt
			very easy but not precise
			divide by 1000 to get dt in seconds rather than milliseconds

		Dt = Clock.tick() - previous_time()
			more complex but very precise
 USER INPUT
    2 ways
        - in the event loop but you can only have one so not useful for complex games
        - using pygame.key and pygame.mouse
            can be called anywhere in the code and very useful with classes.


#####
#player movement from project 1
    player_rect.center += player_direction * player_speed * dt
    if player_rect.right > window_WIDTH or player_rect.left < 0:
        player_direction[0] *= -1
        player_direction[1] = redirect[1]
    if player_rect.bottom > window_HEIGHT or player_rect.top < 0:
        player_direction[1] *= -1
        player_direction = redirect
######

SPRITES
    an in-built pygame class that always contains a surface and a rect

    pygame.sprite.Sprite

    we inherit from it, overriding
    self.image = surface
    self.rect = rect

    to display a sprite, we use SPRITE GROUPS
        they draw, update, and organise sprites

        pygame.sprite.Group()
        we can add a class to the group by
            group.add(class)
            or
            in the actual class, in the init method, add the group to the argument and then call it in the super dunder init method
            e.g
                def__init__(self, groups):
                super().__init__(groups)

        DRAW:
            groups.draw(surface) #draws all sprites on surface
        UPDATE:
            groups.update(args) #calls update with argument on every sprite
        we can also loop over sprites and use them in other methods, making them easy to sort into logical groups.


COLLISSIONS
    GETTING THE COLLISION SIDE
        we move and check collisisons on the horizontal and vertical axis separately
         that way we only have to figure out whether the collision happened on the left or right side of the player.
         this can be checked using the direction.
         this approach only works if 1 object is moving.



         NOTE TO SELF: HIT BOX THING LATER ON : 4:17:29 timestamp

CAMERAS
    The display surface cannot be changed.
    therefore, to create a camera, we need to change where things are drawn.
    The position of the rect does NOT  change. we only draw it in a different position

    how?
        by customising the sprite group drawing logic
        Group.draw is a for loop that blits sprites on a surface


#They are all different files
Game.py:
import pygame, sys, os
from settings import *
from player import Player
from sprites import *
from random import randint
from pytmx.util_pygame import load_pygame
from groups import AllSprites

class Game:   #using a class because there are different games and the other games could easily inherit the attributes of this parent class
    def __init__(self):
        pygame.init()  # initialise pygame
        self.screen = pygame.display.set_mode((screen_width, screen_height), pygame.RESIZABLE)  # create the screen
        pygame.display.set_caption('Serene acres')
        self.clock = pygame.time.Clock() # creating a clock
        self.running = True

        #groups:
        self.all_sprites = AllSprites()
        self.collision_sprites = pygame.sprite.Group()

        self.setup()

        #sprites
        self.player = Player((400,300), self.all_sprites, self.collision_sprites)

    def setup (self):
        map = load_pygame(os.path.join('..', 'graphics', 'map.tmx'))



        # for i in range(6):
        #     x,y = randint(0, screen_width), randint(0, screen_height)
        #     w,h = randint(60,100), randint(60, 100)
        #
        #     CollisionSprite((x,y), (w,h), self.all_sprites, self.collision_sprites)

    def setup(self):
        map = load_pygame(os.path.abspath(os.path.join('..', 'graphics', 'map stuff', 'Map.tmx')))


        #tile layers
        for x,y, image in map.get_layer_by_name("Lake").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("Ground").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("Ground2").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("HighGround").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("Decor").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("DecorTop").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)
        for x,y, image in map.get_layer_by_name("HighDecor").tiles():
            Sprite((x * tile_size,y * tile_size), image, self.all_sprites)

        #object layers
        for obj  in map.get_layer_by_name("natural collisions"):
            CollisionSprite((obj.x, obj.y), obj.image, self.all_sprites, self.collision_sprites)
        for obj  in map.get_layer_by_name("Hitboxes"):
            CollisionSprite(( obj.x, obj.y), pygame.Surface((obj.width, obj.height)),  self.collision_sprites)


        #btw don't forget to block out areas on map
        #see link for help
        # https://youtu.be/8OMghdHP-zs?si=4PXQjn6IG8gbTxTv&t=16830




    def run(self):  # game running method

        while self.running:
            dt = self.clock.tick() / 1000  # getting the delta time and dividing by 1000 to get it in seconds rather than milliseconds

            #event loop
            for event in pygame.event.get():  #game updater, will check for different events in the game
                if event.type == pygame.QUIT: #checking for a game exit
                    pygame.quit()
                    sys.exit()

            #update
            self.screen.fill('black')  # so we don't accidentally see the previous frame
            self.all_sprites.update(dt)
            #draw
            self.all_sprites.draw(self.player.rect.center)
            pygame.display.update()

# Creating an instance of the game and running it
if __name__ == "__main__": #makes sure game only runs from main
    game = Game()
    game.run()

end game.py

Player.py:
import pygame, os
from settings import *


class Player(pygame.sprite.Sprite):
    def __init__(self, pos, group, collision_sprites):
        super().__init__(group)

        image_path = os.path.join("..","graphics", "char1.png")
        self.image = pygame.image.load(image_path).convert_alpha() #creating the player surface
        self.rect = self.image.get_frect(center = pos) # a rectangle for positioning


        #movement
        self.direction = pygame.Vector2(1,0)
        self.speed = 500
        self.collision_sprites =  collision_sprites

    def input(self):
        keys = pygame.key.get_pressed()
        self.direction.x = int(keys[pygame.K_RIGHT]) - int(keys[pygame.K_LEFT])
        self.direction.y = int(keys[pygame.K_DOWN]) - int(keys[pygame.K_UP])

    def move(self,dt):
        self.direction = self.direction.normalize() if self.direction else self.direction
        self.rect.x += self.direction.x * self.speed * dt
        self.collision('horizontal')
        self.rect.y += self.direction.y * self.speed * dt
        self.collision('vertical')



    def collision(self, direction):
        for sprite in self.collision_sprites: #getting all obstacles
            if sprite.rect.colliderect(self.rect):
                if direction == 'horizontal':
                    if self.direction.x > 0 : self.rect.right = sprite.rect.left
                    if self.direction.x < 0 : self.rect.left = sprite.rect.right
                if direction == 'vertical':
                    if self.direction.y > 0 : self.rect.bottom = sprite.rect.top
                    if self.direction.y < 0: self.rect.top = sprite.rect.bottom


    def update(self, dt):
        self.input()
        self.move(dt)


end player.py

groups.py:
import pygame
from settings import *


class AllSprites(pygame.sprite.Group):
    def __init__(self, scale_factor=2):
        super().__init__()
        self.display_surface = pygame.display.get_surface()
        self.offset = pygame.Vector2(0, 0)
        self.scale_factor = scale_factor

    def draw(self, target_pos):
        self.offset.x = (-target_pos[0] * self.scale_factor) + (self.display_surface.get_width() // 2 )
        self.offset.y = (-target_pos[1]  * self.scale_factor) + (self.display_surface.get_height() // 2 )

        for sprite in self:
            # Scale the sprite image
            scaled_image = pygame.transform.scale(sprite.image,
                                                  (sprite.rect.width * self.scale_factor,
                                                   sprite.rect.height * self.scale_factor))

            # Adjust position based on offset and scaling
            scaled_pos = (sprite.rect.topleft + self.offset) * self.scale_factor


            self.display_surface.blit(scaled_image, scaled_pos)



end groups.py

sprites.py:
import pygame
from settings import *


class Sprite(pygame.sprite.Sprite):
    def __init__(self, pos, surf, *group):
        super().__init__(*group)
        self.image = surf
        self.rect = self.image.get_frect(topleft = pos)



class CollisionSprite(pygame.sprite.Sprite):
    def __init__(self, pos, surf, scale_factor = 2, *group):
        super().__init__(*group)
        self.image = surf
        self.rect = self.image.get_frect(topleft = pos)
        self.scale_factor = scale_factor

    def update(self):
         self.rect.width *= self.scale_factor
         self.rect.height *= self.scale_factor
end sprites.py

settings.py :
screen_width = 800 #screen values
screen_height = 800

tile_size = 16
scale_factor = 2

end settings.py

level.py:
import pygame
from settings import *
from player import Player

class Level:
    def __init__(self):

        #getting the display surface
        self.display_surface = pygame.display.get_surface()

        #sprite group
        self.all_sprites = pygame.sprite.Group()

        self.setup()

    def setup(self):
        self.player = Player((40,200), self.all_sprites)


    def run(self, dt):
        self.display_surface.fill('black') #so we don't accidentally see the previous frame
        self.all_sprites.draw(self.display_surface) #creating a place to draw sprites on and in this case, the display surface we created earlier
        self.all_sprites.update() #updates the sprites just like we update the screen




end level.py

this is some code given to me by a mentor to show me how to animate and customise my character sprite. Explain everything here section by section to me, like you would to a 13 year old.
After doing so, You would then Implement these logics into my existing documents, I would do is change the actual graphics lol but yeah

doc 1, character.py:
import pygame
from support import import_image, import_tilemap


class Character(pygame.sprite.Sprite):
    def __init__(self, group):
        # general sprite setup
        super().__init__(group)
        self.image = pygame.Surface((50, 100))
        self.rect = self.image.get_frect(center=(500, 400))

        # background of the sprite is set to yellow and a colorkey is set for the same color, that way any pixel that is pure green (0,255,0) will be invisible and the default sprite image is invisible
        self.image.fill((0, 255, 0))
        self.image.set_colorkey((0, 255, 0))

        # movement
        self.direction = pygame.Vector2(0, 0)
        self.speed = 100

        # animation
        self.frame_index = 0
        self.face_direction = 'down'

        # customization setup
        self.character_frames_index = 0
        self.hat_frames_index = 0

        self.asset_imports()

    def asset_imports(self):
        # the import functions are in support.py; if those look confusing check out this video of mine for importing things into pygame: https://www.youtube.com/watch?v=fFTV6FLPbZo
        self.character_frames = {
            'base': import_tilemap(4, 4, 'character_base'),
            'red': import_tilemap(4, 4, 'character_red'),
        }
        self.hat_frames = {
            'none': None,
            'blue': import_image('hat_blue'),
            'red': import_image('hat_red'),
        }

    def input(self):
        keys = pygame.key.get_pressed()
        self.direction.x = int(keys[pygame.K_RIGHT]) - int(keys[pygame.K_LEFT])
        self.direction.y = int(keys[pygame.K_DOWN]) - int(keys[pygame.K_UP])
        self.direction = self.direction.normalize() if self.direction else self.direction

        # customization input
        keys_pressed = pygame.key.get_just_pressed()
        if keys_pressed[pygame.K_a]:
            self.character_frames_index = (self.character_frames_index + 1) % len(self.character_frames)
        if keys_pressed[pygame.K_s]:
            self.hat_frames_index = (self.hat_frames_index + 1) % len(self.hat_frames)

    def animate(self, dt):
        # the image gets filled with a green color first, since we have a green colorkey (from the init method) this clears the image and we can draw things from scratch
        self.image.fill((0, 255, 0))
        self.frame_index += 2 * dt

        # the main character gets selected from self.character_frames_index which is set on line 49 and 50 via the a key, it is just an integer that goes through the options
        # from self.character_frames we get a dictionary with all the surfaces and we use self.character_frames_index to select one of that
        selected_character_frame = list(self.character_frames.keys())[self.character_frames_index]

        # once the right animation is selected we can blit the image via the animation
        animation = self.character_frames[selected_character_frame][self.face_direction]
        self.image.blit(animation[int(self.frame_index) % len(animation)])

        # the hat is just blitted on top of the animation and works in a similar way compared to the character animation
        if self.hat_frames[list(self.hat_frames.keys())[self.hat_frames_index]]:
            self.image.blit(self.hat_frames[list(self.hat_frames.keys())[self.hat_frames_index]], (15, 4))

    def get_state(self):
        if self.direction.x != 0:
            self.face_direction = 'left' if self.direction.x < 0 else 'right'
        elif self.direction.y != 0:
            self.face_direction = 'up' if self.direction.y < 0 else 'down'

    def move(self, dt):
        self.rect.center += self.direction * self.speed * dt

    def update(self, dt):
        self.input()
        self.get_state()
        self.move(dt)
        self.animate(dt)
end character.py

main.py:
import pygame
from character import Character

pygame.init()
display_surface = pygame.display.set_mode((1280,720))
running = True
sprites = pygame.sprite.Group()
clock = pygame.time.Clock()
character = Character(sprites)
font = pygame.font.Font(None, 40)
text = font.render("press 'a' to change character skin \npress 's' to change hat",True, (255,255,255), (30,30,30))

while running:
    dt = clock.tick() / 1000
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
    sprites.draw(display_surface)
    display_surface.fill((30,30,30))
    sprites.update(dt)
    sprites.draw(display_surface)

    display_surface.blit(text)

    pygame.display.update()
pygame.quit()
end main.py

support.py:
from pygame import image, Rect, Surface
from os.path import join
# import functions
def import_image(*path, alpha = True, format = 'png'):
    full_path = join(*path) + f'.{format}'
    surf = image.load(full_path).convert_alpha() if alpha else image.load(full_path).convert()
    return surf

def import_tilemap(cols, rows, *path):
    frames = {}
    surf = import_image(*path)
    cell_width, cell_height = surf.get_width() / cols, surf.get_height() / rows
    for col in range(cols):
        for row in range(rows):
            cutout_rect = Rect(col * cell_width, row * cell_height,cell_width,cell_height)
            cutout_surf = Surface((cell_width, cell_height))
            cutout_surf.fill('green')
            cutout_surf.set_colorkey('green')
            cutout_surf.blit(surf, (0,0), cutout_rect)
            frames[(col, row)] = cutout_surf
	# via the lines above we import a spritesheet (you can find that in the graphics folder) and save every image in a dictionary where the key is a tuple with the columna and row and the value is the actual surface
    # the topleft image, for example, is the key value pair "(0,0)" : Surface

    # the first row of the animation is the down walking animation, the second row is the up walking animation etc; by organizing all of this we make the character animations much easier.
    organized_frames = {
		'down': [frames[(i,0)] for i in range(4)],
        'up': [frames[(i,1)] for i in range(4)],
        'left': [frames[(i,2)] for i in range(4)],
        'right': [frames[(i,3)] for i in range(4)],

    }
    return organized_frames
end support.py

import sys

import pygame
import os

pygame.init()
display = pygame.display.set_mode((480, 270))
pygame.display.set_caption("My Game")
clock = pygame.time.Clock()

background = pygame.image.load(os.path.join("..","assets","Game Objects", "Background.png")).convert_alpha()
floor_surf = pygame.image.load(os.path.join("..","assets","Game Objects", "Foreground.png")).convert_alpha()
game_font = pygame.font.Font(os.path.join("..","assets","Fonts", "Starborn.ttf"), 10)
panel_surf = pygame.image.load(os.path.join("..","assets","UI Elements", "Panel.png")).convert_alpha()
panel_rect = panel_surf.get_rect(topleft=(0, 0))
score_surf = game_font.render("Score", True, '#faf1e8')
score_rect = score_surf.get_rect(center=(130, 20))

obstacle_surf = pygame.image.load(os.path.join("..","assets","Game Objects", "Obstacle_1.png")).convert_alpha()
obstacle_surf = pygame.transform.scale(obstacle_surf, (50, 50))
obs_position = 500
obs_speed = -4
obs_rect = obstacle_surf.get_rect(midbottom=(obs_position, 230))

player_surf = pygame.image.load(os.path.join("..","assets","Game Objects", "Teddy_Bear.png")).convert_alpha()
player_surf = pygame.transform.scale(player_surf, (70, 70))
player_rect = player_surf.get_rect(midbottom=(80, 230))
player_gravity = -50

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        # if event.type == pygame.MOUSEMOTION:
        #   print(event.pos)
        #   if player_rect.collidepoint(event.pos):
        #     print("collision")

        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            player_gravity = -50

    pygame.display.update()
    display.blit(background, (0, 0))
    display.blit(floor_surf, (0, 10))
    display.blit(panel_surf, panel_rect)
    display.blit(score_surf, score_rect)

    clock.tick(60)

    display.blit(obstacle_surf, obs_rect)
    obs_rect.x += obs_speed
    if obs_rect.right <= 0:
        obs_rect.left = 500

    # player
    player_gravity += 1
    display.blit(player_surf, player_rect)
    player_rect.y += player_gravity

    # make my player surface able to jump
    if player_rect.bottom >= 230:
        player_rect.bottom = 230
        player_gravity = 0


